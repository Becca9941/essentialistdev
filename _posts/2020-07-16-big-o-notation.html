---
layout: post
author: Becca
category: tech
tags: [syntax, algorithms]
featured_image: big-o-notation.svg
hero_caption: 'Research source for this article: <a href="https://pragprog.com/titles/jwdsal2/" target="_blank">A Common-Sense Guide to Data Structures and Algorithms by Jay Wengrow</a>'
leading: Some algorithms can be completed in a set number of steps, no matter how many elements there are to work with (efficient). Whilst others take many more steps (less efficient).
---

<h2>Feedback Is Awesome!</h2>

<p>After sharing this article the other day on <a href="https://twitter.com/Becca9941" target="_blank">Twitter</a>, lots of people responded and offered their own insights, feedback and suggestions. This is one of the reasons I love Twitter, because without that engagement all of those learning opportunities might not have happened, especially not so quickly.</p>

<p>I updated this post to incorporate all of the feedback, by embedding the tweets directly in the post (that was fun!).</p>

<h2>What is Big O Notation?</h2>

<p>Big O Notation is a mathematical concept that allows us to easily categorize how efficient an algorithm is.</p>

<p>The number of steps that an algorithm takes is the main indicator of how efficient it is. If we have an array of 100 elements, and we want to find out the index of a specific value in that array, it could take up to 100 steps for us to find the value by checking each index individually (linear search), or it could take us 7 steps if the array was ordered and we took a higher or lower guessing game approach to finding the number (binary search).</p>

<p>The number of steps it takes to complete a linear or binary search algorithm etc, will depend on how big the array is, and a bunch of other factors.</p>

<h2>When is Big O Useful?</h2>

<p>Big O is useful when you are working with extremely large input sizes. With smaller inputs the difference between the effectiveness of algorithms is pretty much irrelevent.</p>

<p>If you look at the graph below, you'll see that the fewer elements there are, the closer the efficiency lines are. The difference in efficiency only become marked once the number of elements have increased significantly.</p>

<img src="/assets/images/article-images/{{ page.featured_image }}" alt="graph showing efficiency matters more when there are more elements">

<p>For more information on this, I found the C2 wiki article <a href="https://wiki.c2.com/?BigOh" target="_blank">Big Oh</a> to be helpful.</p>

<p>Huge thanks to <a href="https://twitter.com/xpmatteo?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1283678672432627713%7Ctwgr%5E&ref_url=http%3A%2F%2Flocalhost%3A4000%2Ftech%2F2020%2F07%2F16%2Fbig-o-notation.html" target="_blank">Matteo Vaccari</a> and <a href="https://twitter.com/consolondon?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1283685379602882561%7Ctwgr%5E&ref_url=http%3A%2F%2Flocalhost%3A4000%2Ftech%2F2020%2F07%2F16%2Fbig-o-notation.html" target="_blank">Marco Consolaro</a> for helping me address this gap in the article! Here are the original tweets that inspired it:</p>

<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr">A number of steps proportional to the N, for all N larger than some number</p>&mdash; Matteo Vaccari (@xpmatteo) <a href="https://twitter.com/xpmatteo/status/1283678672432627713?ref_src=twsrc%5Etfw">July 16, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">I don’t want to nitpick a divulgation article, it’s ok to simplify, but make it clear to your readers that big O is really about behavior of algorithms when N gets very large</p>&mdash; Matteo Vaccari (@xpmatteo) <a href="https://twitter.com/xpmatteo/status/1283682948823252992?ref_src=twsrc%5Etfw">July 16, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">For me the point is that if the elements are few, the effectiveness of the algorithm is irrelevant (all are anyway fast and the gain or loss is minimal) while with a big number of elements the effectiveness of the algorithm is fundamental (see the wide divergence on the right)</p>&mdash; Marco Consolaro (@consolondon) <a href="https://twitter.com/consolondon/status/1283685379602882561?ref_src=twsrc%5Etfw">July 16, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr">When it is not clear, I would favor simplicity and wait for a signal from the whole system before optimize. If that becomes a bottleneck sooner or later it will surface applying the theory of constraints.</p>&mdash; Marco Consolaro (@consolondon) <a href="https://twitter.com/consolondon/status/1283688715013980160?ref_src=twsrc%5Etfw">July 16, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2>Big O: Count the steps</h2>

<p>Big O achieves consistency by focusing only on the number of steps that an algorithm takes.</p>

<p>When we read data from an array by specifying it's index, that only takes one step because the computer knows the memory address for each index in an array, and can jump straight to it. The way to express this in Big O Notation is:</p>

<p>O(1)</p>

<p>Some people read this as "Big Oh of 1", or "Order of 1".</p>

<p>O(1) means that an algorithm takes the same number of steps no matter how much data there is. In this case, reading from an array always takes just one step no matter how much data the array contains.</p>

<p>Other operations that fall under the category of O(1) are the insertion and deletion of a value at the end of an array.</p>

<p>In the case of a linear search, the number of steps it takes to complete in the worst-case scenario, is the same number of steps as there are elements in the array. So, for N elements in the array, linear search can take up to a maximum of N steps.</p>

<p>O(N)</p>

<p>Oh of N, is the Big O way of saying that for N elements inside an array, the algorithm would take N steps to complete.</p>

<p>Big O Notation does more than describe the number of steps that an algorithm takes, like a hard number such as 22 or 400. It describes how many steps an algorithm takes <em>based on the number of data elements that the algorithm is acting upon.</em></p>

<p>Another way of saying this is that Big O answers the following question: <em>How</em> does the number of steps change as the data increases?</p>

<p>When an array increases in size by one element, the O(N) algorithm will increase by one step. Whilst an algorithm that is O(1) will take the same number of steps no matter how large the array gets.</p>

<p>When plotted on a graph (see below), the O(N) makes a perfect diagonal line. This is because for every additional piece of data, the algorithm takes one additional step. O(N) is also known as linear time.</p>

<p>Whereas O(1) is a perfect horizontal line, because the number of steps in the algorithm remains constant no matter how much data there is.</p>

<img src="/assets/img/big-o-notation-graph.png" alt="big o notation graph showing O(N) and O(1)">

<p>Big O is primarily concerned about how an algorithm performs across varying amounts of data. This means, that as long as an algorithm always takes the same number of steps to perform regardless of how much data there is, then the algorithm would also be described as O(1).</p>

<p>If we are looking for a value that happens to be in the first index of an array (best case scenario), then the efficiency of the linear search in that example could be described as O(1) as it only took one step to complete. However, Big O notation generally refers only to <em>worst case</em> scenarios unless otherwise specified.</p>

<p>Knowing exactly how inefficient an algorithm can get in a worst-case scenario prepares us for the worst and may have a strong impact on our choices.</p>

<h3>O(log N)</h3>

<p>We can't describe a binary search as being O(1), because the number of steps increases as the data increases. It also doesn't fit into the category of O(N), because the number of steps is much fewer than the number of elements that it searches, only seven steps for an array containing one hundred elements.</p>

<p>Binary search seems to fall somewhere in between O(1) and O(N). In Big O, we describe binary search as having a time complexity of O(log N). This type of algorithm is also known as having a time complexity of <em>log time</em>.</p>

<p>O(log N) is the Big O way of describing an algoritm that <em>increases one step each time the data is doubled</em>.</p>

<h4>Logarithms</h4>

<p>Logarithms are the inverse of exponents (the power to which a given number or expression is to be raised, like 2<sup>3</sup> or 2 * 2 * 2, which is 8).</p>

<p>log<sub>2</sub> 8 is the converse (Switching the hypothesis and conclusion of a conditional statement) of the above. It means, how many times do you have to multiply 2 by itself to get a result of 8.</p>

<p>Another example, 2<sup>6</sup> translates to 2 * 2 * 2 * 2 * 2 * 2 = 64.</p>

<p>Since we had to multiply 2 by itself 6 times to get 64, log<sub>2</sub> 64 = 6</p>

<p>Another way of explaining log<sub>2</sub> 8 is: if we kept dividing 8 by 2 until we ended up with 1, how many 2s would we have in our equation (8/2/2/2 = 1). In this example it takes 3 times. So log<sub>2</sub> 8 = 3.</p>

<p>Or, we could explain log<sub>2</sub> 64 as: <strong>how many times do we need to halve 64 until we end up with 1?</strong> (6 times)</p>

<h4>Back to O(log N)</h4>

<p>Whenever we say O(log N), it's actually shorthand for saying O(log2 N). We're just ommitting the small 2 for convenience.</p>

<p>O(log N) means that for N data elements, the algorithm would take log<sub>2</sub> N steps. If there are 8 elements, the algorithm would take three steps, since log<sub>2</sub> 8 = 3.</p>

<p>Said another way, if we keep dividing the eight elements in half, it would take us three steps until we end up with one element.</p>

<p>This is exactly what happens with binary search. As we search for a particular item, we keep dividing the array's cells in half until we narrow it down to the correct number.</p>

<p><strong>O(log N) means that the algorithm takes as many steps as it takes to keep halving the data elements until we remain with one.</strong></p>

<h2>Practical Examples</h2>


{% highlight kotlin linenos %}
things = ["apples", "baboons", "cribs", "pinapples"]
for thing in things:
  print "Here's a thing: %s" % thing
{% endhighlight %}


<p>We would describe the efficiency of this algorithm in Big O Notation like this: O(N) because the number of times we print the elements in the array depends on how many elements are in the array.</p>

{% highlight kotlin linenos %}print 'Hello world!'{% endhighlight %}

<p>We would describe the efficiency of this algorithm like this: O(1) because this print statement consistently takes only one step to achieve.</p>


{% highlight kotlin linenos %}
def in_prime(number):
  for i in range(2, number):
    if number % i == 0:
      return False
    return True
  end
end
{% endhighlight %}


<p>We would describe the efficiency of this algorith like this: O(N), because the number of times the program loops through the numbers in the range depends on which number is given as the end of the range.</p>

<h2>What About Other O Notations?</h2>

<p>Thank you to <a href="https://twitter.com/TommasoPreviero" target="_blank">Tommaso Previero</a> for pointing out that there are a few Big O Notation Types not covered in this article.</p>

<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr">Beautiful! But shouldn&#39;t O(n log n) be in the picture as well? 🤔 I don&#39;t fully remember though...</p>&mdash; Tommaso Previero (@TommasoPreviero) <a href="https://twitter.com/TommasoPreviero/status/1284017092975624193?ref_src=twsrc%5Etfw">July 17, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>And thank you to <a href="https://twitter.com/commitsbyjoyce?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1283780551934185473%7Ctwgr%5E&ref_url=https%3A%2F%2Fpublish.twitter.com%2F%3Fquery%3Dhttps3A2F2Ftwitter.com2Fcommitsbyjoyce2Fstatus2F1283780551934185473widget%3DTweet" target="_blank">Joyce Kung</a> for adding that Big O Measures the Upper-bound of an algorithm might take. So Big O measures the efficiency of an alorithm in the worst-case scenario (e.g. If for example a value you were searching for happened to be the last item in an array, then that might take 10 steps instead of one if it was in the first item in the array. Big O calculates the efficiency assuming that all 10 steps might be taken.</p>


<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr">something that might be cool to clarify in your post is that Big O is a measure of the *upper-bound* of how many steps an algorithm might take (whereas Big θ and Ω measure a tight/lower bound respectively) - but thank you for the writeup, I thought it was a really good overview!</p>&mdash; joyce ✨ kung (@commitsbyjoyce) <a href="https://twitter.com/commitsbyjoyce/status/1283780551934185473?ref_src=twsrc%5Etfw">July 16, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
